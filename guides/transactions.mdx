---
title: "Transactions Integration"
description: "Complete guide to handling transactions and transfers with HR API"
---

## Overview

Transactions are the core of the HR API system, representing the movement of money between accounts. This guide covers how to create, monitor, and manage transactions effectively.

## Transaction Types

<CardGroup cols={2}>
  <Card title="Incoming Transactions" icon="arrow-down">
    - Payments received into virtual accounts
    - Customer payments
    - Refunds and reversals
    - Real-time notifications
  </Card>
  <Card title="Outgoing Transactions" icon="arrow-up">
    - Transfers to recipients
    - Currency conversions
    - Fee payments
    - Settlement transactions
  </Card>
</CardGroup>

## Transaction Lifecycle

<Steps>
  <Step title="Transaction Created">
    Transaction is initiated with recipient and amount details
  </Step>
  <Step title="Payment Confirmation">
    Source payment is confirmed and received
  </Step>
  <Step title="Processing">
    Currency conversion and blockchain operations
  </Step>
  <Step title="Completion">
    Funds are sent to recipient and transaction is finalized
  </Step>
</Steps>

## Creating Transfer Requests

### Basic Transfer Request

<CodeGroup>

```javascript JavaScript
async function createTransferRequest(transferData) {
  try {
    const response = await fetch('https://api.railsfromthecrypt.com/v1/transfer-requests', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        amount: transferData.amount,
        currency: transferData.currency,
        rate: transferData.rate,
        pair: transferData.pair,
        received_amount: transferData.receivedAmount,
        fee: transferData.fee,
        recipient_id: transferData.recipientId
      })
    });

    if (!response.ok) {
      throw new Error('Failed to create transfer request');
    }

    const transfer = await response.json();
    console.log('Transfer request created:', transfer);
    
    return transfer;
  } catch (error) {
    console.error('Error creating transfer request:', error);
    throw error;
  }
}
```

```python Python
import requests

def create_transfer_request(transfer_data):
    try:
        response = requests.post(
            'https://api.railsfromthecrypt.com/v1/transfer-requests',
            headers={
                'Authorization': f'Bearer {access_token}',
                'Content-Type': 'application/json'
            },
            json={
                'amount': transfer_data['amount'],
                'currency': transfer_data['currency'],
                'rate': transfer_data['rate'],
                'pair': transfer_data['pair'],
                'received_amount': transfer_data['received_amount'],
                'fee': transfer_data['fee'],
                'recipient_id': transfer_data['recipient_id']
            }
        )
        
        if not response.ok:
            raise Exception('Failed to create transfer request')
        
        transfer = response.json()
        print('Transfer request created:', transfer)
        
        return transfer
        
    except Exception as e:
        print(f'Error creating transfer request: {e}')
        raise
```

</CodeGroup>

### Complete Transfer Flow

<CodeGroup>

```javascript JavaScript
class TransferManager {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  async initiateTransfer(amount, currency, recipientId) {
    try {
      // Step 1: Get exchange rate
      const rate = await this.getExchangeRate(currency, 'USDC');
      
      // Step 2: Calculate amounts
      const calculations = this.calculateAmounts(amount, rate);
      
      // Step 3: Create transfer request
      const transfer = await this.createTransferRequest({
        amount: amount,
        currency: currency,
        rate: rate.rate,
        pair: `${currency}/USDC`,
        received_amount: calculations.receivedAmount,
        fee: calculations.fee,
        recipient_id: recipientId
      });
      
      // Step 4: Return payment instructions
      return {
        transfer,
        paymentInstructions: this.generatePaymentInstructions(transfer)
      };
    } catch (error) {
      console.error('Failed to initiate transfer:', error);
      throw error;
    }
  }
  
  async getExchangeRate(fromCurrency, toCurrency) {
    const response = await fetch('https://api.railsfromthecrypt.com/v1/rates/calculator', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        from_currency: fromCurrency,
        to_currency: toCurrency,
        amount: '1000000' // 1M for rate calculation
      })
    });
    
    return await response.json();
  }
  
  calculateAmounts(amount, rateData) {
    const fee = parseFloat(rateData.fee);
    const receivedAmount = parseFloat(amount) - fee;
    
    return {
      fee: fee.toString(),
      receivedAmount: receivedAmount.toString()
    };
  }
  
  generatePaymentInstructions(transfer) {
    return {
      amount: transfer.amount,
      currency: transfer.currency,
      reference: transfer.reference,
      instructions: `Send ${transfer.amount} ${transfer.currency} to complete your transfer. Use reference: ${transfer.reference}`
    };
  }
}
```

</CodeGroup>

## Monitoring Transactions

### Real-time Transaction Tracking

<CodeGroup>

```javascript JavaScript
class TransactionMonitor {
  constructor(apiClient) {
    this.apiClient = apiClient;
    this.activeTransfers = new Map();
  }
  
  async startMonitoring(transferId) {
    const transfer = await this.getTransfer(transferId);
    this.activeTransfers.set(transferId, transfer);
    
    // Start polling for updates
    this.pollTransferStatus(transferId);
    
    return transfer;
  }
  
  async pollTransferStatus(transferId) {
    const maxAttempts = 60; // 10 minutes with 10-second intervals
    let attempts = 0;
    
    while (attempts < maxAttempts) {
      try {
        const transfer = await this.getTransfer(transferId);
        
        if (transfer.status === 'completed') {
          console.log('Transfer completed:', transfer);
          this.activeTransfers.delete(transferId);
          this.onTransferCompleted(transfer);
          return;
        } else if (transfer.status === 'failed') {
          console.log('Transfer failed:', transfer);
          this.activeTransfers.delete(transferId);
          this.onTransferFailed(transfer);
          return;
        }
        
        // Still processing, wait and retry
        await new Promise(resolve => setTimeout(resolve, 10000));
        attempts++;
        
      } catch (error) {
        console.error('Error monitoring transfer:', error);
        attempts++;
      }
    }
    
    console.log('Transfer monitoring timeout');
    this.activeTransfers.delete(transferId);
  }
  
  async getTransfer(transferId) {
    const response = await fetch(`https://api.railsfromthecrypt.com/v1/transfer-requests/${transferId}`, {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });
    
    return await response.json();
  }
  
  onTransferCompleted(transfer) {
    // Handle successful transfer
    console.log('Transfer completed successfully:', transfer);
    // Update UI, send notifications, etc.
  }
  
  onTransferFailed(transfer) {
    // Handle failed transfer
    console.log('Transfer failed:', transfer);
    // Show error message, retry options, etc.
  }
}
```

</CodeGroup>

### Webhook-based Monitoring

<CodeGroup>

```javascript JavaScript
// Webhook handler for transaction events
app.post('/webhooks/hr', (req, res) => {
  const event = req.body;
  
  switch (event.type) {
    case 'transaction.created':
      handleTransactionCreated(event.data);
      break;
    case 'transaction.processing':
      handleTransactionProcessing(event.data);
      break;
    case 'transaction.completed':
      handleTransactionCompleted(event.data);
      break;
    case 'transaction.failed':
      handleTransactionFailed(event.data);
      break;
    default:
      console.log('Unknown transaction event:', event.type);
  }
  
  res.status(200).send('OK');
});

function handleTransactionCreated(data) {
  console.log('Transaction created:', data);
  
  // Update UI to show pending status
  updateTransactionStatus(data.reference, 'pending');
  
  // Send notification to user
  notifyUser(data.reference, 'Transaction created, awaiting payment');
}

function handleTransactionProcessing(data) {
  console.log('Transaction processing:', data);
  
  // Update UI to show processing status
  updateTransactionStatus(data.reference, 'processing');
  
  // Show progress indicator
  showProgressIndicator(data.reference);
}

function handleTransactionCompleted(data) {
  console.log('Transaction completed:', data);
  
  // Update UI to show completed status
  updateTransactionStatus(data.reference, 'completed');
  
  // Send success notification
  notifyUser(data.reference, 'Transaction completed successfully');
  
  // Process completion (update database, send confirmation, etc.)
  processTransactionCompletion(data);
}

function handleTransactionFailed(data) {
  console.log('Transaction failed:', data);
  
  // Update UI to show failed status
  updateTransactionStatus(data.reference, 'failed');
  
  // Send failure notification
  notifyUser(data.reference, `Transaction failed: ${data.reason}`);
  
  // Handle failure (refund, retry options, etc.)
  handleTransactionFailure(data);
}
```

</CodeGroup>

## Payment Confirmation

### Confirm Payment for Transfer

<CodeGroup>

```javascript JavaScript
async function confirmPayment(transferId) {
  try {
    const response = await fetch(`https://api.railsfromthecrypt.com/v1/transfer-requests/${transferId}/confirm-payment`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    if (!response.ok) {
      throw new Error('Failed to confirm payment');
    }

    const confirmedTransfer = await response.json();
    console.log('Payment confirmed:', confirmedTransfer);
    
    return confirmedTransfer;
  } catch (error) {
    console.error('Error confirming payment:', error);
    throw error;
  }
}

// Alternative: Confirm by reference
async function confirmPaymentByReference(reference) {
  try {
    const response = await fetch(`https://api.railsfromthecrypt.com/v1/transfer-requests/reference/${reference}/confirm-payment`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    if (!response.ok) {
      throw new Error('Failed to confirm payment');
    }

    const confirmedTransfer = await response.json();
    console.log('Payment confirmed:', confirmedTransfer);
    
    return confirmedTransfer;
  } catch (error) {
    console.error('Error confirming payment:', error);
    throw error;
  }
}
```

</CodeGroup>

## Transaction History

### Get Transaction List

<CodeGroup>

```javascript JavaScript
async function getTransactions(filters = {}) {
  try {
    const params = new URLSearchParams();
    
    if (filters.status) params.append('status', filters.status);
    if (filters.limit) params.append('limit', filters.limit);
    if (filters.page) params.append('page', filters.page);
    
    const response = await fetch(`https://api.railsfromthecrypt.com/v1/transactions?${params}`, {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    if (!response.ok) {
      throw new Error('Failed to get transactions');
    }

    const transactions = await response.json();
    return transactions;
  } catch (error) {
    console.error('Error getting transactions:', error);
    throw error;
  }
}

// Usage examples
const allTransactions = await getTransactions();
const pendingTransactions = await getTransactions({ status: 'pending' });
const completedTransactions = await getTransactions({ 
  status: 'completed', 
  limit: 20, 
  page: 1 
});
```

</CodeGroup>

### Get Transaction Details

<CodeGroup>

```javascript JavaScript
async function getTransactionById(transactionId) {
  try {
    const response = await fetch(`https://api.railsfromthecrypt.com/v1/transactions/${transactionId}`, {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    if (!response.ok) {
      throw new Error('Failed to get transaction');
    }

    const transaction = await response.json();
    return transaction;
  } catch (error) {
    console.error('Error getting transaction:', error);
    throw error;
  }
}

async function getTransactionByReference(reference) {
  try {
    const response = await fetch(`https://api.railsfromthecrypt.com/v1/transactions/reference/${reference}`, {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    if (!response.ok) {
      throw new Error('Failed to get transaction');
    }

    const transaction = await response.json();
    return transaction;
  } catch (error) {
    console.error('Error getting transaction:', error);
    throw error;
  }
}
```

</CodeGroup>

## Transaction Events

### Understanding Transaction Events

Each transaction includes an events array that tracks its lifecycle:

<CodeGroup>

```javascript JavaScript
function parseTransactionEvents(transaction) {
  const events = transaction.events || [];
  
  const eventMap = {
    'awaiting_payment': {
      status: 'pending',
      description: 'Awaiting payment confirmation',
      userMessage: 'Please complete your payment to proceed'
    },
    'payment_completed': {
      status: 'processing',
      description: 'Payment completed',
      userMessage: 'Payment received, processing your transaction'
    },
    'processing': {
      status: 'processing',
      description: 'Processing transaction',
      userMessage: 'Converting currency and preparing transfer'
    },
    'completed': {
      status: 'completed',
      description: 'Transaction completed successfully',
      userMessage: 'Your transfer has been completed'
    },
    'failed': {
      status: 'failed',
      description: 'Transaction failed',
      userMessage: 'Transaction failed, please contact support'
    }
  };
  
  return events.map(event => ({
    ...event,
    ...eventMap[event.status]
  }));
}

// Usage
const transaction = await getTransactionById(transactionId);
const parsedEvents = parseTransactionEvents(transaction);

parsedEvents.forEach(event => {
  console.log(`${event.timestamp}: ${event.userMessage}`);
});
```

</CodeGroup>

## Error Handling

### Transaction Error Handling

<CodeGroup>

```javascript JavaScript
class TransactionErrorHandler {
  static handle(error, transaction = null) {
    const errorMap = {
      'INSUFFICIENT_FUNDS': {
        message: 'Insufficient funds for this transaction',
        action: 'Please add funds to your account',
        retryable: false
      },
      'INVALID_RECIPIENT': {
        message: 'Invalid recipient address',
        action: 'Please check the recipient details',
        retryable: false
      },
      'RATE_EXPIRED': {
        message: 'Exchange rate has expired',
        action: 'Please create a new transaction',
        retryable: true
      },
      'NETWORK_ERROR': {
        message: 'Network error occurred',
        action: 'Please try again in a few minutes',
        retryable: true
      },
      'TRANSACTION_FAILED': {
        message: 'Transaction failed to process',
        action: 'Please contact support',
        retryable: false
      }
    };
    
    const errorInfo = errorMap[error.code] || {
      message: 'An unexpected error occurred',
      action: 'Please contact support',
      retryable: false
    };
    
    return {
      ...errorInfo,
      code: error.code,
      transaction: transaction,
      timestamp: new Date().toISOString()
    };
  }
  
  static async retryTransaction(transactionId) {
    try {
      // Get the original transaction
      const originalTransaction = await getTransactionById(transactionId);
      
      // Create a new transaction with the same details
      const newTransaction = await createTransferRequest({
        amount: originalTransaction.amount,
        currency: originalTransaction.currency,
        recipient_id: originalTransaction.recipient_id
      });
      
      return newTransaction;
    } catch (error) {
      console.error('Failed to retry transaction:', error);
      throw error;
    }
  }
}

// Usage
try {
  const transfer = await createTransferRequest(transferData);
} catch (error) {
  const errorInfo = TransactionErrorHandler.handle(error);
  
  console.error(errorInfo.message);
  
  if (errorInfo.retryable) {
    // Show retry option to user
    showRetryOption(errorInfo);
  } else {
    // Show error message
    showErrorMessage(errorInfo);
  }
}
```

</CodeGroup>

## Best Practices

### Transaction Management

<AccordionGroup>
  <Accordion title="Pre-transaction Validation">
    - Validate recipient addresses
    - Check account balances
    - Verify exchange rates
    - Confirm user permissions
  </Accordion>
  <Accordion title="Real-time Updates">
    - Use webhooks for status updates
    - Implement WebSocket connections
    - Show progress indicators
    - Provide clear status messages
  </Accordion>
  <Accordion title="Error Recovery">
    - Implement retry mechanisms
    - Handle network failures
    - Provide clear error messages
    - Offer alternative solutions
  </Accordion>
</AccordionGroup>

### Performance Optimization

<AccordionGroup>
  <Accordion title="Caching">
    - Cache exchange rates
    - Store transaction history
    - Implement request deduplication
    - Use appropriate cache TTL
  </Accordion>
  <Accordion title="Monitoring">
    - Track transaction success rates
    - Monitor processing times
    - Set up failure alerts
    - Regular performance reviews
  </Accordion>
  <Accordion title="Scalability">
    - Use connection pooling
    - Implement request queuing
    - Handle high transaction volumes
    - Plan for traffic spikes
  </Accordion>
</AccordionGroup>

## Common Use Cases

### Remittance Service

<CodeGroup>

```javascript JavaScript
class RemittanceService {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  async sendMoney(sender, recipient, amount, currency) {
    try {
      // Step 1: Validate sender and recipient
      await this.validateSender(sender);
      await this.validateRecipient(recipient);
      
      // Step 2: Check compliance requirements
      await this.checkCompliance(sender, recipient, amount);
      
      // Step 3: Create transfer request
      const transfer = await this.createTransferRequest({
        amount: amount,
        currency: currency,
        recipient_id: recipient.id
      });
      
      // Step 4: Send payment instructions
      await this.sendPaymentInstructions(sender, transfer);
      
      // Step 5: Monitor transaction
      this.monitorTransaction(transfer.id);
      
      return transfer;
    } catch (error) {
      console.error('Failed to send money:', error);
      throw error;
    }
  }
  
  async validateSender(sender) {
    // Check sender KYC status, limits, etc.
    if (!sender.kycVerified) {
      throw new Error('Sender must complete KYC verification');
    }
  }
  
  async validateRecipient(recipient) {
    // Check recipient details, limits, etc.
    if (!recipient.isValid) {
      throw new Error('Invalid recipient details');
    }
  }
  
  async checkCompliance(sender, recipient, amount) {
    // Check AML, sanctions, etc.
    if (amount > sender.dailyLimit) {
      throw new Error('Amount exceeds daily limit');
    }
  }
}
```

</CodeGroup>

### E-commerce Payment Processing

<CodeGroup>

```javascript JavaScript
class EcommercePaymentProcessor {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  async processOrderPayment(order) {
    try {
      // Step 1: Create transfer request for order
      const transfer = await this.createTransferRequest({
        amount: order.total,
        currency: order.currency,
        recipient_id: order.merchant.recipientId
      });
      
      // Step 2: Store order with transfer details
      await this.storeOrder({
        ...order,
        transferId: transfer.id,
        status: 'pending_payment'
      });
      
      // Step 3: Send payment instructions to customer
      await this.sendPaymentInstructions(order.customer, transfer);
      
      // Step 4: Monitor payment
      this.monitorPayment(transfer.id, order.id);
      
      return transfer;
    } catch (error) {
      console.error('Failed to process order payment:', error);
      throw error;
    }
  }
  
  async handlePaymentReceived(transferId, orderId) {
    try {
      // Update order status
      await this.updateOrderStatus(orderId, 'paid');
      
      // Process fulfillment
      await this.processFulfillment(orderId);
      
      // Send confirmation to customer
      await this.sendOrderConfirmation(orderId);
      
    } catch (error) {
      console.error('Failed to handle payment received:', error);
      throw error;
    }
  }
}
```

</CodeGroup>

## Troubleshooting

### Common Issues

<CardGroup cols={2}>
  <Card title="Transaction Stuck" icon="clock">
    - Check payment confirmation
    - Verify recipient details
    - Contact support with transaction ID
    - Allow processing time (1-3 days)
  </Card>
  <Card title="Payment Not Confirmed" icon="exclamation">
    - Verify payment was sent
    - Check reference number
    - Confirm account details
    - Contact support for assistance
  </Card>
  <Card title="Exchange Rate Issues" icon="chart-line">
    - Rates expire after 5 minutes
    - Create new transaction for fresh rate
    - Check rate calculation
    - Monitor rate changes
  </Card>
  <Card title="Recipient Errors" icon="user">
    - Validate recipient address
    - Check recipient status
    - Verify network compatibility
    - Update recipient details
  </Card>
</CardGroup>

## Support

### Getting Help

For transaction-related issues:

1. **Check transaction status** - Use the API to get current status
2. **Review error messages** - Check the transaction events and error details
3. **Contact support** - Email [support@hashrails.xyz](mailto:support@hashrails.xyz) with transaction details

### Resources

<CardGroup cols={2}>
  <Card
    title="API Reference"
    icon="book"
    href="/api/transactions/list"
  >
    Complete API documentation for transactions
  </Card>
  <Card
    title="Webhooks Guide"
    icon="webhook"
    href="/concepts/webhooks"
  >
    Set up real-time transaction notifications
  </Card>
  <Card
    title="Error Handling"
    icon="exclamation-triangle"
    href="/concepts/error-handling"
  >
    Handle transaction errors and edge cases
  </Card>
  <Card
    title="Support"
    icon="headset"
    href="mailto:support@hashrails.xyz"
  >
    Get help from our support team
  </Card>
</CardGroup>
